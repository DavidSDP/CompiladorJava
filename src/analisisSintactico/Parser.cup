package analisisSintactico;

import Checkers.Tipo;
import Checkers.TipoOperador;
import Checkers.TypeCheck;
import Errores.ErrorHandler;
import Errores.ErrorSemantico;
import Errores.ErrorSintactico;
import Procesador.GlobalVariables;
import Procesador.EntornoClase;
import SimbolosNoTerminales.*;
import java_cup.runtime.Symbol;
import Procesador.Identificador;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import Procesador.Declaracion;

parser code {:


	/** Trata errores de tipo sintáctico **/
	@Override
	public void report_error(String message, Object info) {
		if(info != null) {
			ComplexSymbol simboloEncontrado = (ComplexSymbol) info;
			ErrorHandler.reportaError(new ErrorSintactico(simboloEncontrado));
		}else {
			ErrorHandler.reportaError(""+message);
		}
	}
	
	/** Para controlar que el parser no imprima texto de los errores por pantalla **/
	@Override
	public void syntax_error(Symbol token) {
		report_error("Syntax error", token);
	}
	@Override
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("\nCould not recover and keep parsing\n", null);
	}

 :}

terminal    String			TCLASS, TVAR, TFINAL, TRETURN, TVOID, TIF, TWHILE, TELSE, LLAVEIZQ, LLAVEDER;
terminal    String			IGUAL, PUNTOCOMA, COMA, PARENIZQ, PARENDER, CORCHIZQ, CORCHDER;
terminal	String			COMPARADOR, OPLOGICO, VBOOLEANO, OPSUMA, OPPROD;
terminal	String			VSTRING;
terminal	String			VNUMERO;
terminal	String			VID;

non terminal	SimboloBucle		bucle;
non terminal	SimboloCondicional	condicional;
non terminal	SimboloCondElse		condelse;
non terminal	SimboloExpresion	expresion;
non terminal	SimboloPrograma		programa;
non terminal	SimboloClase		clase;
non terminal	SimboloCuerpo		cuerpo;
non terminal	SimboloElemento		elemento;
non terminal	SimboloAsignacion	asignacion;
non terminal  	SimboloFactor		factor;
non terminal	SimboloOperacion	Operacion;
non terminal	SimboloOperacion	Operacion1;
non terminal	SimboloOperacion	Operacion2;
non terminal	SimboloOperacion	Operacion3;
non terminal  	SimboloFuncionInvk	funcionInvk;
non terminal	SimboloFuncionDecl	funcionDecl;
non terminal	SimboloArgs			args;
non terminal	SimboloArgDecl		argDecl;
non terminal	SimboloArgs			nextArg;
non terminal	SimboloContenido	contenido;
non terminal	SimboloParams		params;
non terminal	SimboloParams		nextParam;
non terminal  SimboloCondicionBucle cond_bucle;
non terminal  M1;
non terminal  SimboloCondicionalBloquePrincipal cond_main_block;
non terminal  SimboloClausulaCondicion clausula_cond;
non terminal	SimboloArray 		arrayAsig;
non terminal	SimboloArray 		arrayDef;
non terminal	SimboloInicializacion inicializacion;
non terminal 	SimboloDeclaracion	declaracion;

precedence left OPSUMA, OPPROD;
precedence left OPLOGICO, COMPARADOR;

start with programa;

programa ::=  												{: GlobalVariables.entraBloqueClase(null);
 																GlobalVariables.declaraBuiltInFunctions((EntornoClase)GlobalVariables.entornoActual());
															:}
			clase:c
															{: GlobalVariables.saleBloqueClase();
																RESULT = new SimboloPrograma(c);
															:}
			;
			
clase	::=	TCLASS:t VID:i 									{: try{
																GlobalVariables.asignaClaseID(i);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
															:}
			LLAVEIZQ 										{: GlobalVariables.entraBloqueClase(new Declaracion(new Identificador(i, i), Tipo.Class));
															:}
			cuerpo:c										{: GlobalVariables.saleBloqueClase();
																
															:}
			LLAVEDER										{: RESULT = new SimboloClase(i,c);
															:}
			;
			
cuerpo ::= cuerpo:c elemento:e 								{: RESULT = new SimboloCuerpo(c,e); :}
			|												{: RESULT = null; :}
			;
			
elemento ::= declaracion:d									{: RESULT = new SimboloElemento(d); :}
			| funcionDecl:f									{: RESULT = new SimboloElemento(f); :}
			| clase:c										{: RESULT = new SimboloElemento(c); :}
			;

inicializacion ::= IGUAL Operacion:o PUNTOCOMA				{: RESULT = new SimboloInicializacion(o); :}
			| PUNTOCOMA										{: RESULT = new SimboloInicializacion(); :}
			;

declaracion ::= TVAR:t VID:i arrayAsig:a inicializacion:init 
			{:  
				Boolean esArray = (a != null);
				try{
					if(esArray)
						GlobalVariables.asignaArray(i,t,a);
					else
						GlobalVariables.asignaID(i,t);
						
					if(esArray && (init.getSimboloOperacion() != null))
						TypeCheck.lanzaErrorArrayNoInicializable();
						
					if(init.getSimboloOperacion()!=null)
						TypeCheck.typesMatchAsignacion(i,Tipo.getTipo(t), init.getSimboloOperacion().getTipoSubyacente());
				
				}catch(ErrorSemantico e){
					ErrorHandler.reportaError(e);
				}
				RESULT = new SimboloDeclaracion(i,Tipo.getTipo(t),esArray,init);
			:}
															
			| TFINAL TVAR:t VID:i inicializacion:init	
			{: 	
				try{
					GlobalVariables.asignaIDConstante(i,t);
					if(init.getSimboloOperacion()!=null)
						TypeCheck.typesMatchAsignacion(i,Tipo.getTipo(t), init.getSimboloOperacion().getTipoSubyacente());
					else
						TypeCheck.lanzaErrorConstanteNoInicializada(i, t);
				}catch(ErrorSemantico e){
					ErrorHandler.reportaError(e);
				}
				RESULT = new SimboloDeclaracion(i, Tipo.getTipo(t), false, init);
			:}
			;
															
asignacion ::= VID:i arrayAsig:a IGUAL Operacion:o PUNTOCOMA 
			{: 
				try{
					if(a != null){
						GlobalVariables.compruebaIDArray(i);
						TypeCheck.typesMatchAsignacionArray(i, o.getTipoSubyacente());
					}else{
						GlobalVariables.compruebaID(i);
						GlobalVariables.compruebaAsignacionPermitida(i);
						TypeCheck.typesMatchAsignacion(GlobalVariables.entornoActual().fullGet(i).getId().getId(), GlobalVariables.entornoActual().fullGet(i).getTipo(), o.getTipoSubyacente());
					}
				}catch(ErrorSemantico e){
					ErrorHandler.reportaError(e);
				}
				RESULT = new SimboloAsignacion(i,o);
			:}
			;
			
arrayAsig  ::= CORCHIZQ VNUMERO:n CORCHDER					{: RESULT = new SimboloArray(n); :}
		 	|												{: RESULT = null; :}
		 	;
arrayDef   ::= CORCHIZQ CORCHDER							{: RESULT = new SimboloArray(); :}
		 	|												{: RESULT = null; :}
			;

funcionDecl ::= TVAR:t VID:i 								{: 	try{
																	GlobalVariables.asignaFuncionID(i,t);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
															:}
				PARENIZQ									{: GlobalVariables.entraBloqueFuncion(new Declaracion(new Identificador(i, i), Tipo.getTipo(t)));
																GlobalVariables.asignaEntornoFuncionID(i);
															:}
				args:a										{: GlobalVariables.asignaFuncionArgs(i,a);
															:}
				PARENDER LLAVEIZQ							{: :}
				contenido:c									{: GlobalVariables.saleBloqueFuncion(false);
															:}
				LLAVEDER									{: RESULT = new SimboloFuncionDecl(i,Tipo.getTipo(t),a,c);
															:}
				|
				TVOID:t VID:i 								{: 	try{
																	GlobalVariables.asignaFuncionID(i,Tipo.Void);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
															:}
				PARENIZQ									{: GlobalVariables.entraBloqueFuncion(new Declaracion(new Identificador(i, i), Tipo.Void));
																GlobalVariables.asignaEntornoFuncionID(i);
															:}
				args:a										{: GlobalVariables.asignaFuncionArgs(i,a);
															:}
				PARENDER LLAVEIZQ							{: :}
				contenido:c									{: GlobalVariables.saleBloqueFuncion(false);
															:}
				LLAVEDER									{: RESULT = new SimboloFuncionDecl(i,Tipo.Void,a,c);
															:}
			;
		
funcionInvk ::= VID:i PARENIZQ params:p PARENDER			{: 
																try{
																	GlobalVariables.compruebaFuncionID(i);
																	TypeCheck.parameterMatch(i,p);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloFuncionInvk(i,p);
															:}
		;
		
args ::= argDecl:a nextArg:n								{: 
																RESULT = new SimboloArgs(a,n,true);
															:}
		| 													{: 
																RESULT = null;
															:}
		;

nextArg ::= COMA argDecl:d nextArg:n						{:
																RESULT = new SimboloArgs(d,n,false);
															:}
		|													{: 
																RESULT = null;
															:}
		;
		
argDecl ::= TVAR:t VID:i arrayDef:a 						{:  try{
																	if(a!=null)
																		GlobalVariables.asignaArray(i,t,a);
																	else
																		GlobalVariables.asignaID(i,t);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloArgDecl(i,Tipo.getTipo(t),a);
															:}
		;
		
contenido ::= contenido:c expresion:e						{: RESULT = new SimboloContenido(c,e); :}
			| contenido:c condicional:d						{: RESULT = new SimboloContenido(c,d); :}
			| contenido:c bucle:b							{: RESULT = new SimboloContenido(c,b); :}
			| contenido:c TRETURN:r Operacion:o PUNTOCOMA	{: try{
																TypeCheck.returnTypeMatch(o);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloContenido(c,r,o); :}
			| 												{: RESULT = null; :}
			;
		
bucle ::= cond_bucle:cb LLAVEIZQ {: GlobalVariables.entraBloqueWhile(); :}
					contenido:o  {: GlobalVariables.saleBloqueWhile(); :}
					LLAVEDER {: RESULT = new SimboloBucle(cb, o); :}
					;

cond_bucle ::= M1 TWHILE PARENIZQ Operacion:o {:
								try{
									TypeCheck.checkBoolean(o, true);
								} catch(ErrorSemantico e) {
									ErrorHandler.reportaError(e);
								}
								RESULT = new SimboloCondicionBucle(o);
							:}
					  	PARENDER
;

M1 ::= {: /* TODO Generar etiqueta y asignarsela al resultado */ :} ;

condicional     ::= cond_main_block:cmb condelse:e {: RESULT = new SimboloCondicional(cmb, e); :};

cond_main_block ::= clausula_cond:cc LLAVEIZQ {: GlobalVariables.entraBloqueIf(); :}
							  contenido:c {:
									GlobalVariables.saleBloqueIf(); 
									// TODO Aquí se generaria el c3@ de la etiqueta que tiene cc
									// auto i3Direcciones = GlobalVariables.generarC3@(TipoInstr.COND_JUMP, cc.expresion, Valor.FALSO, cc.etiqueta);
									RESULT = new SimboloCondicionalBloquePrincipal(cc, c);
								:}
								LLAVEDER;

clausula_cond   ::= TIF PARENIZQ Operacion:o PARENDER 
									{:
										try {
											TypeCheck.checkBoolean(o, false);
										} catch(ErrorSemantico e) {
											ErrorHandler.reportaError(e);
										} 
									  // TODO Generar etiqueta y propagar dentro del SimboloClausulaCond
									  //  auto et = GlobalVariables.generarEtiqueta();
										//  RESULT = new SimboloClausulaCond(o, et);

										// Ademas, aqui ya podemos generar la condición de salto al caso falso y
										// Necesitaria generar una etiqueta e_test_fallido (por ejemplo) y
										// propagarla para ponerla una vez se ha evaluado el cuerpo del main.
										RESULT = new SimboloClausulaCondicion(o);
									:};
			
condelse ::= TELSE LLAVEIZQ 								{: GlobalVariables.entraBloqueElse(); :}
				contenido:e 								{: GlobalVariables.saleBloqueElse(); :}
				LLAVEDER									{: RESULT = new SimboloCondElse(e); :}
			|												{: RESULT = null; :}
			;
			
expresion ::= asignacion:a 									{: RESULT = new SimboloExpresion(a); :}
			| declaracion:d 								{: RESULT = new SimboloExpresion(d); :}
			| funcionInvk:f PUNTOCOMA						{: RESULT = new SimboloExpresion(f); :}
			;
		
Operacion ::= Operacion1:o									{: RESULT = new SimboloOperacion(o); :}
		| Operacion:o OPSUMA:s Operacion:q						{: 
																try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(s));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(s));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,s,q); :}
		;
	
Operacion1 ::= Operacion2:o									{: RESULT = new SimboloOperacion(o); :}
		| Operacion:o OPPROD:p Operacion:q					{: try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(p));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(p));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,p,q); :}
		;
		
Operacion2 ::= Operacion3:o									{: RESULT = new SimboloOperacion(o); :}
		| Operacion:o COMPARADOR:c Operacion:q 				{: try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(c));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(c));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,c,q); :}
		;
		
Operacion3 ::= factor:f 									{: RESULT = new SimboloOperacion(f); :}
		| Operacion:o OPLOGICO:l Operacion:q					{: try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(l));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(l));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,l,q); :}
		;
	
factor ::= VID:i arrayAsig:a									{: try{
																	GlobalVariables.compruebaID(i);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloFactor(i, Tipo.Identificador);
															:}
		| VNUMERO:n 										{: RESULT = new SimboloFactor(n, Tipo.Integer); :}
		| VBOOLEANO:b										{: RESULT = new SimboloFactor(b, Tipo.Boolean); :}
		| VSTRING:s											{: RESULT = new SimboloFactor(s, Tipo.String); :}
		| funcionInvk:f										{: RESULT = new SimboloFactor(f); :}
		| PARENIZQ Operacion:o PARENDER 					{: RESULT = new SimboloFactor(o); :}
		;
		
params ::= Operacion:o nextParam:n							{: RESULT = new SimboloParams(o,n,true); :}
		| 													{: RESULT = null; :}
		;

nextParam ::= COMA Operacion:o nextParam:n 					{: RESULT = new SimboloParams(o,n,false); :}
			| 												{: RESULT = null; :}
			;
