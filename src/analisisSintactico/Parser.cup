package analisisSintactico;

import Checkers.Tipo;
import Checkers.TipoOperador;
import Checkers.TypeCheck;
import Errores.ErrorHandler;
import Errores.ErrorSemantico;
import Errores.ErrorSintactico;
import Procesador.GlobalVariables;
import Procesador.EntornoClase;
import SimbolosNoTerminales.*;
import java_cup.runtime.Symbol;
import Procesador.Identificador;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

parser code {:


	/** Trata errores de tipo sintáctico **/
	@Override
	public void report_error(String message, Object info) {
		if(info != null) {
			ComplexSymbol simboloEncontrado = (ComplexSymbol) info;
			ErrorHandler.reportaError(new ErrorSintactico(simboloEncontrado));
		}else {
			ErrorHandler.reportaError(""+message);
		}
	}
	
	/** Para controlar que el parser no imprima texto de los errores por pantalla **/
	@Override
	public void syntax_error(Symbol token) {
		report_error("Syntax error", token);
	}
	@Override
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("\nCould not recover and keep parsing\n", null);
	}

 :}

terminal    String			TCLASS, TVAR, TFINAL, TRETURN, TVOID, TIF, TWHILE, TELSE, LLAVEIZQ, LLAVEDER;
terminal    String			IGUAL, PUNTOCOMA, COMA, PARENIZQ, PARENDER, CORCHIZQ, CORCHDER;
terminal	String			COMPARADOR, OPLOGICO, VBOOLEANO, OPSUMA, OPPROD;
terminal	String			VSTRING;
terminal	String			VNUMERO;
terminal	String			VID;

non terminal	SimboloBucle		bucle;
non terminal	SimboloCondicional	condicional;
non terminal	SimboloCondElse		condelse;
non terminal	SimboloExpresion	expresion;
non terminal	SimboloPrograma		programa;
non terminal	SimboloClase		clase;
non terminal	SimboloCuerpo		cuerpo;
non terminal	SimboloElemento		elemento;
non terminal	SimboloAsignacion	asignacion;
non terminal  	SimboloFactor		factor;
non terminal	SimboloOperacion	Operacion;
non terminal	SimboloOperacion	Operacion1;
non terminal	SimboloOperacion	Operacion2;
non terminal	SimboloOperacion	Operacion3;
non terminal  	SimboloFuncionInvk	funcionInvk;
non terminal	SimboloFuncionDecl	funcionDecl;
non terminal	SimboloArgs			args;
non terminal	SimboloArgs			nextArg;
non terminal	SimboloContenido	contenido;
non terminal	SimboloParams		params;
non terminal	SimboloParams		nextParam;

precedence left OPSUMA, OPPROD;
precedence left OPLOGICO, COMPARADOR;

start with programa;

programa ::=  												{: GlobalVariables.entraBloqueClase(null);
 																GlobalVariables.declaraBuiltInFunctions((EntornoClase)GlobalVariables.entornoActual());
															:}
			clase:c
															{: GlobalVariables.saleBloqueClase();
																RESULT = new SimboloPrograma(c);
															:}
			;
			
clase	::=	TCLASS:t VID:i 									{: try{
																GlobalVariables.asignaClaseID(i);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
															:}
			LLAVEIZQ 										{: GlobalVariables.entraBloqueClase(new Identificador(i, Tipo.Class));
															:}
			cuerpo:c										{: GlobalVariables.saleBloqueClase();
																
															:}
			LLAVEDER										{: RESULT = new SimboloClase(i,c);
															:}
			;
			
cuerpo ::= cuerpo:c elemento:e 								{: RESULT = new SimboloCuerpo(c,e); :}
			|												{: RESULT = null; :}
			;
			
elemento ::= asignacion:a 									{: RESULT = new SimboloElemento(a); :}
			| funcionDecl:f									{: RESULT = new SimboloElemento(f); :}
			| clase:c										{: RESULT = new SimboloElemento(c); :}
			;
			
asignacion ::= TVAR:t VID:i									{: try{
																	GlobalVariables.asignaID(i,t);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
															:}
				IGUAL Operacion:o PUNTOCOMA 				{: try{
																	TypeCheck.typesMatchAsignacion(i,Tipo.getTipo(t), o.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloAsignacion(t,i,o);
															:}
			| TVAR:t VID:i array:a PUNTOCOMA 						{: 
																try{
																	if(array) {
																		GlobalVariables.asignaIDArray(i, t);
																	} else {
																		GlobalVariables.asignaID(i,t);
																	}
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloAsignacion(t,i);
															:}
			| VID:i array						{: 
																GlobalVariables.compruebaID(i);
																GlobalVariables.compruebaAsignacionPermitida(i);
															:}
				IGUAL Operacion:o PUNTOCOMA 				{: 
																try{
																	TypeCheck.typesMatchAsignacion(GlobalVariables.entornoActual().fullGet(i).getId(), GlobalVariables.entornoActual().fullGet(i).getTipo(), o.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloAsignacion(i,o);
															:}
			| TFINAL TVAR:t VID:i 							{: try{
																	GlobalVariables.asignaIDConstante(i,t);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
															:}
				IGUAL Operacion:o PUNTOCOMA					{: 
																try{
																	TypeCheck.typesMatchAsignacion(i,Tipo.getTipo(t), o.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloAsignacion(t,i,o);
															:}
			;

funcionDecl ::= TVAR:t VID:i 								{: 	try{
																	GlobalVariables.asignaFuncionID(i,t);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
															:}
				PARENIZQ									{: GlobalVariables.entraBloqueFuncion(new Identificador(i, Tipo.getTipo(t)));
																GlobalVariables.asignaEntornoFuncionID(i);
															:}
				args:a										{: GlobalVariables.asignaFuncionArgs(i,a);
															:}
				PARENDER LLAVEIZQ							{: :}
				contenido:c									{: GlobalVariables.saleBloqueFuncion(false);
															:}
				LLAVEDER									{: RESULT = new SimboloFuncionDecl(i,Tipo.getTipo(t),a,c);
															:}
				|
				TVOID:t VID:i 								{: 	try{
																	GlobalVariables.asignaFuncionID(i,Tipo.Void);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
															:}
				PARENIZQ									{: GlobalVariables.entraBloqueFuncion(new Identificador(i, Tipo.Void));
																GlobalVariables.asignaEntornoFuncionID(i);
															:}
				args:a										{: GlobalVariables.asignaFuncionArgs(i,a);
															:}
				PARENDER LLAVEIZQ							{: :}
				contenido:c									{: GlobalVariables.saleBloqueFuncion(false);
															:}
				LLAVEDER									{: RESULT = new SimboloFuncionDecl(i,Tipo.Void,a,c);
															:}
			;
		
funcionInvk ::= VID:i										{: GlobalVariables.compruebaFuncionID(i);
															:}
				PARENIZQ params:p 							{: TypeCheck.parameterMatch(i,p); :}
				PARENDER									{: RESULT = new SimboloFuncionInvk(i,p);
															:}
		;
		
args ::= TVAR:t VID:i array:a		{: 
																		if (array) {
																			GlobalVariables.asignaIDArray(i, t);
																		} else {
																			GlobalVariables.asignaID(i,t);
																		}
															:}
			nextArg:n										{: RESULT = new SimboloArgs(t,i,n,true);
															:}
		| 													{: RESULT = null;
															:}
		;

nextArg ::= COMA TVAR:t VID:i array	{: 
																		if (array) {
																			GlobalVariables.asignaIDArray(i, t);
																		} else {
																			GlobalVariables.asignaID(i, t);
																		}
															:}
				nextArg:n									{: RESULT = new SimboloArgs(t,i,n,false);
															:}
		|													{: RESULT = null;
															:}
		;
		
contenido ::= contenido:c expresion:e						{: RESULT = new SimboloContenido(c,e); :}
			| contenido:c condicional:d						{: RESULT = new SimboloContenido(c,d); :}
			| contenido:c bucle:b							{: RESULT = new SimboloContenido(c,b); :}
			| contenido:c TRETURN:r Operacion:o PUNTOCOMA	{: try{
																TypeCheck.returnTypeMatch(o);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloContenido(c,r,o); :}
			| 												{: RESULT = null; :}
			;
			
bucle ::= TWHILE PARENIZQ Operacion:o 				{:  try{
															TypeCheck.checkBoolean(o,true);
														}catch(ErrorSemantico e){
															ErrorHandler.reportaError(e);
														}
													:}
				PARENDER LLAVEIZQ 					{: GlobalVariables.entraBloqueWhile(); :}
				contenido:c 						{: GlobalVariables.saleBloqueWhile(); :}
				LLAVEDER							{: RESULT = new SimboloBucle(o,c); :}
				;

condicional ::= TIF PARENIZQ Operacion:o 					{: try{
																TypeCheck.checkBoolean(o,false);
															}catch(ErrorSemantico e){
																ErrorHandler.reportaError(e);
															}
															:}
				PARENDER LLAVEIZQ							{: GlobalVariables.entraBloqueIf(); :}
				contenido:c 								{: GlobalVariables.saleBloqueIf(); :}
				LLAVEDER									{: :}
				condelse:e									{: RESULT = new SimboloCondicional(o,c,e); :}
			;
			
condelse ::= TELSE LLAVEIZQ 								{: GlobalVariables.entraBloqueElse(); :}
				contenido:e 								{: GlobalVariables.saleBloqueElse(); :}
				LLAVEDER									{: RESULT = new SimboloCondElse(e); :}
			|												{: RESULT = null; :}
			;
			
expresion ::= asignacion:a 									{: RESULT = new SimboloExpresion(a); :}
			| funcionInvk:f PUNTOCOMA						{: RESULT = new SimboloExpresion(f); :}
			;
		
Operacion ::= Operacion1:o									{: RESULT = new SimboloOperacion(o); :}
		| Operacion:o OPSUMA:s Operacion:q						{: 
																try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(s));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(s));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,s,q); :}
		;
	
Operacion1 ::= Operacion2:o									{: RESULT = new SimboloOperacion(o); :}
		| Operacion:o OPPROD:p Operacion:q					{: try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(p));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(p));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,p,q); :}
		;
		
Operacion2 ::= Operacion3:o									{: RESULT = new SimboloOperacion(o); :}
		| Operacion:o COMPARADOR:c Operacion:q 				{: try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(c));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(c));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,c,q); :}
		;
		
Operacion3 ::= factor:f 									{: RESULT = new SimboloOperacion(f); :}
		| Operacion:o OPLOGICO:l Operacion:q					{: try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(l));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(l));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,l,q); :}
		;
	
factor ::= VID:i array				{:
																// TODO Llegado el momento aqui se tiene que comprobar
																// si la variable es un array y si el indice esta 
																// dentro del rango, si es posible establecerlo en tiempo de
																// de compilacion. Si no se tendrán que meter las isntr
																// necesarias para garantizar que no hay overflow
																try{
																	GlobalVariables.compruebaID(i);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloFactor(i, Tipo.Identificador);
															:}
		| VNUMERO:n 										{: RESULT = new SimboloFactor(n, Tipo.Integer); :}
		| VBOOLEANO:b										{: RESULT = new SimboloFactor(b, Tipo.Boolean); :}
		| VSTRING:s											{: RESULT = new SimboloFactor(s, Tipo.String); :}
		| funcionInvk:f										{: RESULT = new SimboloFactor(f); :}
		| PARENIZQ Operacion:o PARENDER 					{: RESULT = new SimboloFactor(o); :}
		;
		
params ::= Operacion:o nextParam:n							{: RESULT = new SimboloParams(o,n,true); :}
		| 													{: RESULT = null; :}
		;

nextParam ::= COMA Operacion:o nextParam:n 					{: RESULT = new SimboloParams(o,n,false); :}
			| 												{: RESULT = null; :}
			;


/*
Las cosas se pueden hacer de diferentes maneras llegados a este punto:
	1. Podemos tener 2 producciones para la declaracion de arrays para 
		 simplificar la gramatica y comprobar en las rutinas semanticas
     que tenemos un rango/indice declarado para todo lo que no sea declaracion
     de parametros

  2. Podemos tener 2 producciones diferentes 1 para la declaracion de variables y 
     su uso en en el codigo de las funciones. Y otra para la declaracion de parametros 
     de funcion

Poll is now on!
*/

// Ojo! el numero no es un numero es un string. Esto tiene que cambiar
array  ::= CORCHIZQ VNUMERO:n CORCHDER {: RESULT = new SimboloArray(n); :}
					 | CORCHIZQ CORCHDER; {: RESULT = new SimboloArray(); :}
