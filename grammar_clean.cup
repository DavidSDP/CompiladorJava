package analisisSintactico;

import Checkers.Tipo;
import Checkers.TipoOperador;
import Checkers.TypeCheck;
import Errores.ErrorHandler;
import Errores.ErrorSemantico;
import Errores.ErrorSintactico;
import Procesador.GlobalVariables;
import Procesador.EntornoClase;
import SimbolosNoTerminales.*;
import java_cup.runtime.Symbol;
import Procesador.Identificador;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;


terminal    String      TCLASS, TVAR, TFINAL, TRETURN, TVOID, TIF, TWHILE, TELSE, LLAVEIZQ, LLAVEDER;
terminal    String      IGUAL, PUNTOCOMA, COMA, PARENIZQ, PARENDER, CORCHIZQ, CORCHDER;
terminal  String      COMPARADOR, OPLOGICO, VBOOLEANO, OPSUMA, OPPROD;
terminal  String      VSTRING;
terminal  String      VNUMERO;
terminal  String      VID;

non terminal  SimboloBucle    bucle;
non terminal  SimboloCondicional  condicional;
non terminal  SimboloCondElse   condelse;
non terminal  SimboloExpresion  expresion;
non terminal  SimboloPrograma   programa;
non terminal  SimboloClase    clase;
non terminal  SimboloCuerpo   cuerpo;
non terminal  SimboloElemento   elemento;
non terminal  SimboloAsignacion asignacion;
non terminal    SimboloFactor   factor;
non terminal  SimboloOperacion  Operacion;
non terminal  SimboloOperacion  Operacion1;
non terminal  SimboloOperacion  Operacion2;
non terminal  SimboloOperacion  Operacion3;
non terminal    SimboloFuncionInvk  funcionInvk;
non terminal  SimboloFuncionDecl  funcionDecl;
non terminal  SimboloArgs     args;
non terminal  SimboloArgs     nextArg;
non terminal  SimboloContenido  contenido;
non terminal  SimboloParams   params;
non terminal  SimboloParams   nextParam;

precedence left OPSUMA, OPPROD;
precedence left OPLOGICO, COMPARADOR;



start with programa;

programa    ::= clase:c ;

clase       ::= TCLASS:t VID:i LLAVEIZQ cuerpo:c LLAVEDER ;

cuerpo      ::= cuerpo:c elemento:e 
								| ;

elemento    ::= asignacion:a 
							  | funciondecl:f 
								| clase:c ;

// Cambios para poder admitir arrays
asignacion  ::= TVAR:t VID:i IGUAL Operacion:o PUNTOCOMA
							  | TVAR:t VID:i array PUNTOCOMA // Declaración de un array
								| VID:i array IGUAL Operacion:o PUNTCOMA // Asignacion de un elemento a un array :+1:
								| TFINAL TVAR:t VID:i IGUAL Operacion PUNTOCOMA ; // TODO Tiene sentido declarar un array constante ? Probablemente sí, pero no me quiero meter en este fregado

funcionDecl ::= TVAR:t VID:i PARENIZQ args:a PARENDER LLAVEIZQ contenido:c LLAVEDER
								| TVOID VID:i PARENIZQ args:a PARENDER LLAVEIZQ contenido:c LLAVEDER ;

funcionInvk ::= VID:i PARENIZQ params PARENDER ;


// Cambio para aceptar arrays. Los argumentos declarados en la función pueden ser arrays
args				::= TVAR:t VID:i array nextArg:n 
								| ;

nextArg			::= COMA TVAR:t VID:i array nextArg:n
								| ;

// Ojito, VNUMERO es algo que fijo es un número, pero esto no nos permite declarar arrays
// de tamaño calculado mediante una operación :thumbsup:
array				::= CORCHIZQ VNUMERO CORCHDER
								| CORCHIZQ CORCHDER ;

contenido 	::= contenido expresion:e
								| contenido condicional:d
								| contenido bucle
								| contenido TRETURN:r Operacion:o PUNTOCOMA
								| ;

bucle				::= TWHILE PARENIZQ Operacion:o PARENDER LLAVEIZQ contenido:c LLAVEDER;

condicional ::= TIF PARENIZQ Operacion:o PARENDER LLAVEIZQ contenido LLAVEDER condelse:e ;

condelse    ::= TELSE LLAVEIZQ contenido:e LLAVEDER
								| ;	

expresion  	::= asignacion:a
								| funcionInvk:f PUNTOCOMA;

Operacion		::= Operacion1:o 
								| Operacion:o OPSUMA Operacion:q ;


Operacion1	::= Operacion2:o 
								| Operacion2:o OPPROD Operacion2:q ;


Operacion2	::= Operacion3:o 
								| Operacion3:o COMPARADOR Operacion3:q ;

Operacion3	::= factor:f 
								| Operacion:o OPPROD Operacion:q ;

factor 			::= VID
								| VNUMERO
								| VBOOLEANO
								| VSTRING
								| funcionInvk
								| PARENIZQ Operacion:o PARENDER ;  // Putada extrema, permite cambiar la precedencia de operaciones! Me imagino que esto se hizo así porque daba problema de recursividad :smile:

params 			::= Operacion nextParam
					 			| ;

nextParam 	::= COMA Operacion:o nextParam:n
								| ;


