package analisisSintactico;

// External dependencies
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

// Module dependencies
import Checkers.Tipo;
import Checkers.TipoOperador;
import Checkers.TypeCheck;
import Errores.ErrorHandler;
import Errores.ErrorSemantico;
import Errores.ErrorSintactico;
import Procesador.GlobalVariables;
import Procesador.EntornoClase;
import Procesador.Declaracion;
import Procesador.DeclaracionFuncion;
import Procesador.DeclaracionConstante;
import Procesador.Identificador;
import SimbolosNoTerminales.*;
import intermedio.I3DUtils;
import intermedio.OperacionTresDirecciones;
import intermedio.InstruccionTresDirecciones;

parser code {:


  /** Trata errores de tipo sintáctico **/
	@Override
	public void report_error(String message, Object info) {
		if(info != null) {
			ComplexSymbol simboloEncontrado = (ComplexSymbol) info;
			ErrorHandler.reportaError(new ErrorSintactico(simboloEncontrado));
		}else {
			ErrorHandler.reportaError(""+message);
		}
	}
	
	/** Para controlar que el parser no imprima texto de los errores por pantalla **/
	@Override
	public void syntax_error(Symbol token) {
		report_error("Syntax error", token);
	}
	@Override
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("\nCould not recover and keep parsing\n", null);
	}

 :}

terminal    String			TCLASS, TVAR, TFINAL, TRETURN, TVOID, TIF, TWHILE, TELSE, LLAVEIZQ, LLAVEDER;
terminal    String			IGUAL, PUNTOCOMA, COMA, PARENIZQ, PARENDER, CORCHIZQ, CORCHDER;
terminal	String			COMPARADOR, OPLOGICO, VBOOLEANO, OPSUMA, OPPROD;
terminal	String			VSTRING;
terminal	String			VNUMERO;
terminal	String			VID;

non terminal	SimboloBucle		bucle;
non terminal	SimboloCondicional	condicional;
non terminal	SimboloCondElse		condelse;
non terminal	SimboloExpresion	expresion;
non terminal	SimboloPrograma		programa;
non terminal	SimboloClase		clase;
non terminal	SimboloCuerpo		cuerpo;
non terminal	SimboloElemento		elemento;
non terminal	SimboloAsignacion	asignacion;
non terminal  	SimboloFactor		factor;
non terminal	SimboloOperacion	Operacion;
non terminal	SimboloOperacion	Operacion1;
non terminal	SimboloOperacion	Operacion2;
non terminal	SimboloOperacion	Operacion3;
non terminal  	SimboloFuncionInvk	funcionInvk;
non terminal	SimboloFuncionDecl	funcionDecl;
non terminal	SimboloFuncionDecl	funchead;
non terminal	SimboloFuncionDecl	funcname;
non terminal	SimboloArgs			args;
non terminal	SimboloArgDecl		argDecl;
non terminal	SimboloArgs			nextArg;
non terminal	SimboloContenido	contenido;
non terminal	SimboloParams		params;
non terminal	SimboloParams		nextParam;
non terminal  SimboloCondicionBucle cond_bucle;
non terminal  SimboloEtiqueta M1;
non terminal  SimboloCondicionalBloquePrincipal cond_main_block;
non terminal  SimboloClausulaCondicion clausula_cond;
non terminal	SimboloArray 		arrayAsig;
non terminal	SimboloArray 		arrayDef;
non terminal	SimboloInicializacion inicializacion;
non terminal 	SimboloDeclaracion	declaracion;

precedence left OPSUMA, OPPROD;
precedence left OPLOGICO, COMPARADOR;

start with programa;

programa ::=  												{: GlobalVariables.entraBloqueClase(null);
 																GlobalVariables.declaraBuiltInFunctions((EntornoClase)GlobalVariables.entornoActual());
															:}
			clase:c
															{: GlobalVariables.saleBloqueClase();
																RESULT = new SimboloPrograma(c);
															:}
			;
			
clase	::=	TCLASS:t VID:i 									{: try{
																GlobalVariables.asignaClaseID(i);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
															:}
			LLAVEIZQ 										{: GlobalVariables.entraBloqueClase(new Declaracion(new Identificador(i, i), Tipo.Class));
															:}
			cuerpo:c										{: GlobalVariables.saleBloqueClase();
																
															:}
			LLAVEDER										{: RESULT = new SimboloClase(i,c);
															:}
			;
			
cuerpo ::= cuerpo:c elemento:e 								{: RESULT = new SimboloCuerpo(c,e); :}
			|												{: RESULT = null; :}
			;
			
elemento ::= declaracion:d									{: RESULT = new SimboloElemento(d); :}
			| funcionDecl:f									{: RESULT = new SimboloElemento(f); :}
			| clase:c										{: RESULT = new SimboloElemento(c); :}
			;

inicializacion ::= IGUAL Operacion:o PUNTOCOMA				
			{: 
					RESULT = new SimboloInicializacion(o);
			:}
			| PUNTOCOMA										
			{: 
					RESULT = new SimboloInicializacion(); 
			:}
			;

declaracion ::= TVAR:t VID:i arrayAsig:a inicializacion:init 
			{:  
				Boolean esArray = (a != null);
				Declaracion declResultado = null;
				try{
					if(esArray) {
						// Declaracion de un array
						declResultado = GlobalVariables.asignaArray(i,t,a);
						if(init.getSimboloOperacion()!=null) {
							TypeCheck.lanzaErrorArrayNoInicializable();

							// TODO ¿Como se inicializa un array utilizando c3@?
							// Sabiendo el offset del tipo podrias generar una copia a: @ + idx * sizeTipo ( son vectores unidimensionales )
							// Sin embargo esto obligaría a generar un nuevo tipo de Operando que nos permita redireccionar memoria.
							I3DUtils.crea(OperacionTresDirecciones.COPIA, init.getDeclaracionResultado(), declResultado);						
						}						
					} else {
						// Declaracion simple
						declResultado = GlobalVariables.asignaID(i,t);
						if(init.getSimboloOperacion()!=null) {
							TypeCheck.typesMatchAsignacion(i,Tipo.getTipo(t), init.getSimboloOperacion().getTipoSubyacente());
							I3DUtils.crea(OperacionTresDirecciones.COPIA, init.getDeclaracionResultado(), declResultado);						
						}
					}
						
				}catch(ErrorSemantico e){
					ErrorHandler.reportaError(e);
				}
				// Ojo! Aqui no es necesario propagar la declaracion ya no hay nadie que pueda usarlo en reducciones
				// posteriores. Así que declResultado muere aqui.
				RESULT = new SimboloDeclaracion(i,Tipo.getTipo(t),esArray,init);
			:}
															
			| TFINAL TVAR:t VID:i inicializacion:init	
			{: 
				Declaracion decl = null;
				try{
          decl = GlobalVariables.asignaIDConstante(i,t, init.getDeclaracionResultado());

					if(init.getSimboloOperacion()!=null)
						TypeCheck.typesMatchAsignacion(i,Tipo.getTipo(t), init.getSimboloOperacion().getTipoSubyacente());
					else
						TypeCheck.lanzaErrorConstanteNoInicializada(i, t);

        	I3DUtils.crea(OperacionTresDirecciones.COPIA, init.getDeclaracionResultado(), decl);
				}catch(ErrorSemantico e){
					ErrorHandler.reportaError(e);
				}

				RESULT = new SimboloDeclaracion(i, Tipo.getTipo(t), false, init);
			:}
			;
															
asignacion ::= VID:i arrayAsig:a IGUAL Operacion:o PUNTOCOMA 
			{: 
				try{
					if(a != null){
						GlobalVariables.compruebaIDArray(i);
						TypeCheck.typesMatchAsignacionArray(i, o.getTipoSubyacente());
						// TODO Falta implementar la generacion de codigo para los arrays
					}else{
						Declaracion decl = GlobalVariables.compruebaID(i);
						GlobalVariables.compruebaAsignacionPermitida(i);
						TypeCheck.typesMatchAsignacion(GlobalVariables.entornoActual().fullGet(i).getId().getId(), GlobalVariables.entornoActual().fullGet(i).getTipo(), o.getTipoSubyacente());						
					
        		I3DUtils.crea(OperacionTresDirecciones.COPIA, o.getDeclaracionResultado(), decl);
					}
				}catch(ErrorSemantico e){
					ErrorHandler.reportaError(e);
				}
				// Ojo! Aqui no es necesario propagar la declaracion ya no hay nadie que pueda usarlo en reducciones
				// posteriores. Así que declResultado muere aqui
				RESULT = new SimboloAsignacion(i,o);
			:}
			;
			
arrayAsig  ::= CORCHIZQ VNUMERO:n CORCHDER					{: RESULT = new SimboloArray(n); :}
		 	|												{: RESULT = null; :}
		 	;
arrayDef   ::= CORCHIZQ CORCHDER							{: RESULT = new SimboloArray(); :}
		 	|												{: RESULT = null; :}
			;

funcionDecl ::= funchead:fh LLAVEIZQ contenido:c LLAVEDER
  {:  
      GlobalVariables.saleBloqueFuncion(false);

			I3DUtils.crea(OperacionTresDirecciones.RETORNO, fh.getDeclaracion());
      // Watch out! fh holds a SimboloFuncionDecl instance
      fh.setContenido(c);
      RESULT = fh; 
  :}; 

funchead ::= funcname:fn PARENIZQ args:a PARENDER 
  {:  
      GlobalVariables.asignaFuncionArgs(fn.getId(), a); 
      // Propagate the args upwards
      fn.setArgs(a);
      RESULT = fn; 
  :}; 

funcname ::= TVAR:t VID:i 
  {:  
      DeclaracionFuncion decl = null;
      try{
          decl = GlobalVariables.asignaFuncionID(i, t); 
      } catch(ErrorSemantico e) {
          ErrorHandler.reportaError(e);
      }   

			// Genera lo necesario para poder dirigir las llamadas al procedimiento
			I3DUtils.crea(OperacionTresDirecciones.ETIQUETA, decl.getEtiqueta());
			I3DUtils.crea(OperacionTresDirecciones.PREAMBULO, decl);

      GlobalVariables.entraBloqueFuncion(decl);
      GlobalVariables.asignaEntornoFuncionID(i);
      // Dummy construct to pass the information upwards
      RESULT = new SimboloFuncionDecl(decl, null, null);
  :}  
          | TVOID VID:i
  {:  
      DeclaracionFuncion decl = null;
      try{
          decl = GlobalVariables.asignaFuncionID(i, Tipo.Void);
      } catch(ErrorSemantico e) {
          ErrorHandler.reportaError(e);
      }
   
			// Genera lo necesario para poder dirigir las llamadas al procedimiento
			I3DUtils.crea(OperacionTresDirecciones.ETIQUETA, decl.getEtiqueta());
			I3DUtils.crea(OperacionTresDirecciones.PREAMBULO, decl);

      GlobalVariables.entraBloqueFuncion(decl);
      GlobalVariables.asignaEntornoFuncionID(i);
      // Dummy construct to pass the information upwards
      RESULT = new SimboloFuncionDecl(decl, null, null);
  :}; 
    

funcionInvk ::= VID:i PARENIZQ params:p PARENDER			
	{: 
			DeclaracionFuncion decl = null;
			try{
					decl = GlobalVariables.compruebaFuncionID(i);
					TypeCheck.parameterMatch(i,p);
			}catch(ErrorSemantico e){
					ErrorHandler.reportaError(e);
			}

			// TODO No es aqui, pero ahora mismo no se estan pasando los parametros a la funcion
			// probablemente esto tenga que hacerse en params.

			// Generamos la llamada
			I3DUtils.crea(OperacionTresDirecciones.LLAMADA, decl);
			// TODO Esta variable temporal ahora mismo no sirve de nada, pero de alguna manera
			// Tenemos que propagar el posible resultado (falta mirar el tema de los void)
			// No estoy seguro de que el void se deba retornar como valor de variable
			// intermedia :thinking:
			Declaracion declRetorno = GlobalVariables.crearVariableTemporal(decl.getTipo());			
			RESULT = new SimboloFuncionInvk(decl, declRetorno, i, p);
	:}
		;
		
args ::= argDecl:a nextArg:n								{: 
																RESULT = new SimboloArgs(a,n,true);
															:}
		| 													{: 
																RESULT = null;
															:}
		;

nextArg ::= COMA argDecl:d nextArg:n						{:
																RESULT = new SimboloArgs(d,n,false);
															:}
		|													{: 
																RESULT = null;
															:}
		;
		
argDecl ::= TVAR:t VID:i arrayDef:a 						{:  try{
																	if(a!=null)
																		GlobalVariables.asignaArray(i,t,a);
																	else
																		GlobalVariables.asignaID(i,t);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloArgDecl(i,Tipo.getTipo(t),a);
															:}
		;
		
contenido ::= contenido:c expresion:e						{: RESULT = new SimboloContenido(c,e); :}
			| contenido:c condicional:d						{: RESULT = new SimboloContenido(c,d); :}
			| contenido:c bucle:b							{: RESULT = new SimboloContenido(c,b); :}
			| contenido:c TRETURN:r Operacion:o PUNTOCOMA	{: try{
																TypeCheck.returnTypeMatch(o);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloContenido(c,r,o); :}
			| 												{: RESULT = null; :}
			;
		
bucle ::= cond_bucle:cb LLAVEIZQ {: GlobalVariables.entraBloqueWhile(); :}
					contenido:o  LLAVEDER 
		{: 
				GlobalVariables.saleBloqueWhile(); 
				I3DUtils.crea(OperacionTresDirecciones.GOTO, cb.getEtiquetaStart());
				I3DUtils.crea(OperacionTresDirecciones.ETIQUETA, cb.getEtiquetaFin());
				RESULT = new SimboloBucle(cb, o);
		:};

cond_bucle ::= TWHILE PARENIZQ M1:start Operacion:o PARENDER 
		{:
				try{
						TypeCheck.checkBoolean(o, true);
				} catch(ErrorSemantico e) {
						ErrorHandler.reportaError(e);
				}
				String etFin = GlobalVariables.generarEtiqueta();
				Declaracion falseTemp = GlobalVariables.crearVariableTemporal(Tipo.Integer, 0);
				// TODO No se como tenemos que generar el falso aquí. Tal vez como una constante global ??
				I3DUtils.crea(OperacionTresDirecciones.EQ, o.getDeclaracionResultado(), falseTemp, etFin);
				RESULT = new SimboloCondicionBucle(o, start.getEtiqueta(), etFin);
		:};

M1 ::= 
		{: 
				String etStart = GlobalVariables.generarEtiqueta();
				I3DUtils.crea(OperacionTresDirecciones.ETIQUETA, etStart);
				RESULT = new SimboloEtiqueta(etStart);
		:};

condicional     ::= cond_main_block:cmb condelse:e
    {: 
				I3DUtils.crea(OperacionTresDirecciones.ETIQUETA, cmb.getEtiqueta());
        RESULT = new SimboloCondicional(cmb, e);
    :};

cond_main_block ::= clausula_cond:cc LLAVEIZQ {: GlobalVariables.entraBloqueIf(); :}
							  contenido:c {:
									GlobalVariables.saleBloqueIf(); 
									
                  String etFin = GlobalVariables.generarEtiqueta();
									I3DUtils.crea(OperacionTresDirecciones.GOTO, etFin);
									I3DUtils.crea(OperacionTresDirecciones.ETIQUETA, cc.getEtiqueta());
									RESULT = new SimboloCondicionalBloquePrincipal(cc, c, etFin);
								:}
								LLAVEDER;

clausula_cond   ::= TIF PARENIZQ Operacion:o PARENDER 
			{:
					try {
						TypeCheck.checkBoolean(o, false);
					} catch(ErrorSemantico e) {
						ErrorHandler.reportaError(e);
					} 
  	      String et = GlobalVariables.generarEtiqueta();
					// TODO Forma hacky de hacer que el valor constante False esté en el codigo.
					// Además el valor false y true deberían estar codificados en algun lado para reusarlo
					// en el codigo
					Declaracion falseTemp = GlobalVariables.crearVariableTemporal(Tipo.Integer, 0);
					// TODO No se como tenemos que generar el falso aquí. Tal vez como una constante global ??
					I3DUtils.crea(OperacionTresDirecciones.EQ, o.getDeclaracionResultado(), falseTemp, et);
					RESULT = new SimboloClausulaCondicion(o, et);
			:};
			
condelse ::= TELSE LLAVEIZQ 								{: GlobalVariables.entraBloqueElse(); :}
				contenido:e 								{: GlobalVariables.saleBloqueElse(); :}
				LLAVEDER									{: RESULT = new SimboloCondElse(e); :}
			|												{: RESULT = null; :}
			;
			
expresion ::= asignacion:a 									{: RESULT = new SimboloExpresion(a); :}
			| declaracion:d 								{: RESULT = new SimboloExpresion(d); :}
			| funcionInvk:f PUNTOCOMA						{: RESULT = new SimboloExpresion(f); :}
			;
		
Operacion ::= Operacion1:o
		{: 
				SimboloOperacion operacion = new SimboloOperacion(o);
				operacion.setDeclaracionResultado(o.getDeclaracionResultado());
				RESULT = operacion; 
				
		:}
		| Operacion:o OPSUMA:s Operacion:q
		{: 
				Declaracion declResultadoSuma = null;
				try {
					TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(s));
					TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(s));
					TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());

					declResultadoSuma =  GlobalVariables.crearVariableTemporal(Tipo.Integer);
					I3DUtils.crea(I3DUtils.getTipoOperacion(s), o.getDeclaracionResultado(), q.getDeclaracionResultado(), declResultadoSuma);
				}catch(ErrorSemantico e){
					ErrorHandler.reportaError(e);
				}

				SimboloOperacion resultado = new SimboloOperacion(o,s,q);
				resultado.setDeclaracionResultado(declResultadoSuma);
				RESULT = resultado; 
		:}
		;
	
Operacion1 ::= Operacion2:o
		{:
				SimboloOperacion operacion = new SimboloOperacion(o);
				operacion.setDeclaracionResultado(o.getDeclaracionResultado());
				RESULT = operacion; 
		:}
		| Operacion:o OPPROD:p Operacion:q
		{: 
				Declaracion declResultadoProd = null;
				try{
					TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(p));
					TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(p));
					TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());

					declResultadoProd =  GlobalVariables.crearVariableTemporal(Tipo.Integer);
					I3DUtils.crea(I3DUtils.getTipoOperacion(p), o.getDeclaracionResultado(), q.getDeclaracionResultado(), declResultadoProd);
				} catch(ErrorSemantico e) {
					ErrorHandler.reportaError(e);
				}

				SimboloOperacion resultado = new SimboloOperacion(o,p,q);
				resultado.setDeclaracionResultado(declResultadoProd);
				RESULT = resultado; 
		:}
		;
		
Operacion2 ::= Operacion3:o
		{: 
				SimboloOperacion operacion = new SimboloOperacion(o);
				operacion.setDeclaracionResultado(o.getDeclaracionResultado());
				RESULT = operacion; 
		:}
		| Operacion:o COMPARADOR:c Operacion:q 
		{: 
				Declaracion declResultado = null;
				try{
					TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(c));
					TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(c));
					TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());

					declResultado =  GlobalVariables.crearVariableTemporal(Tipo.Boolean);
					I3DUtils.crea(I3DUtils.getTipoOperacion(c), o.getDeclaracionResultado(), q.getDeclaracionResultado(), declResultado);
				} catch(ErrorSemantico e) {
					ErrorHandler.reportaError(e);
				}
				SimboloOperacion resultado = new SimboloOperacion(o,c,q);
				resultado.setDeclaracionResultado(declResultado);
				RESULT = resultado; 
		:}
		;
		
Operacion3 ::= factor:f 
		{:
				SimboloOperacion operacion = new SimboloOperacion(f);
				operacion.setDeclaracionResultado(f.getDeclaracionResultado());
				RESULT = operacion; 
		:}
		| Operacion:o OPLOGICO:l Operacion:q 
		{: 
				Declaracion declResultado = null;
				try{
					TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(l));
					TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(l));
					TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());

					declResultado =  GlobalVariables.crearVariableTemporal(Tipo.Boolean);
					I3DUtils.crea(I3DUtils.getTipoOperacion(l), o.getDeclaracionResultado(), q.getDeclaracionResultado(), declResultado);
				} catch(ErrorSemantico e) {
					ErrorHandler.reportaError(e);
				}
				SimboloOperacion resultado = new SimboloOperacion(o,l,q);
				resultado.setDeclaracionResultado(declResultado);
				RESULT = resultado; 
		:}
		;
	
factor ::= VID:i arrayAsig:a                  
    {:
        Declaracion decl = null;
        try{
            decl = GlobalVariables.compruebaID(i);
				}catch(ErrorSemantico e){
						ErrorHandler.reportaError(e);
				}
				// TODO Aqui se ha quitado el parametro. Probablemente se debería
				// pasar para pintar todo como toca en el arbol.
        RESULT = new SimboloFactor(decl);
    :}
    | VNUMERO:n                     
    {:
			 	DeclaracionConstante decl =  GlobalVariables.crearVariableTemporal(Tipo.Integer, n);
				Declaracion varDecl = GlobalVariables.crearVariableTemporal(Tipo.Integer);
				I3DUtils.crea(OperacionTresDirecciones.COPIA, decl, varDecl);
				// TODO Aqui se ha quitado el parametro que pasaba el número. Probablemente se debería
				// pasar para pintar todo como toca en el arbol.
        RESULT = new SimboloFactor(varDecl);
    :}
    | VBOOLEANO:b                    
    {: 
			 	DeclaracionConstante decl =  GlobalVariables.crearVariableTemporal(Tipo.Boolean, b);
				Declaracion varDecl = GlobalVariables.crearVariableTemporal(Tipo.Boolean);
				I3DUtils.crea(OperacionTresDirecciones.COPIA, decl, varDecl);				
				// TODO Aqui se ha quitado el parametro. Probablemente se debería
				// pasar para pintar todo como toca en el arbol.
        RESULT = new SimboloFactor(varDecl);
    :}
    | VSTRING:s                      
    {: 
			 	DeclaracionConstante decl =  GlobalVariables.crearVariableTemporal(Tipo.String, s);
				Declaracion varDecl = GlobalVariables.crearVariableTemporal(Tipo.String);
				I3DUtils.crea(OperacionTresDirecciones.COPIA, decl, varDecl);				
				// TODO Aqui se ha quitado el parametro. Probablemente se debería
				// pasar para pintar todo como toca en el arbol.
        RESULT = new SimboloFactor(varDecl); 
    :}
    | funcionInvk:f                    
    {: 
				// En este punto solo tenemos que propagar la declaración del retorno para poder tener en cuenta la variable
				// en otras partes del codigo
        RESULT = new SimboloFactor(f.getDeclaracion()); 
    :}
    | PARENIZQ Operacion:o PARENDER           
    {: 
        RESULT = new SimboloFactor(o.getDeclaracionResultado()); 
		:}
		;
		
params ::= Operacion:o nextParam:n							{: RESULT = new SimboloParams(o,n,true); :}
		| 													{: RESULT = null; :}
		;

nextParam ::= COMA Operacion:o nextParam:n 					{: RESULT = new SimboloParams(o,n,false); :}
			| 												{: RESULT = null; :}
			;
