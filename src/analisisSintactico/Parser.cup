package analisisSintactico;

import Checkers.Tipo;
import Checkers.TipoOperador;
import Checkers.TypeCheck;
import Errores.ErrorHandler;
import Errores.ErrorSemantico;
import Errores.ErrorSintactico;
import Procesador.GlobalVariables;
import Procesador.EntornoClase;
import SimbolosNoTerminales.*;
import java_cup.runtime.Symbol;
import Procesador.Identificador;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

parser code {:


	/** Trata errores de tipo sint�ctico **/
	@Override
	public void report_error(String message, Object info) {
		if(info != null) {
			ComplexSymbol simboloEncontrado = (ComplexSymbol) info;
			ErrorHandler.reportaError(new ErrorSintactico(simboloEncontrado));
		}else {
			ErrorHandler.reportaError(""+message);
		}
	}
	
	/** Para controlar que el parser no imprima texto de los errores por pantalla **/
	@Override
	public void syntax_error(Symbol token) {
		report_error("Syntax error", token);
	}
	@Override
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("\nCould not recover and keep parsing\n", null);
	}

 :}

terminal    String			TCLASS, TVAR, TFINAL, TRETURN, TVOID, TIF, TWHILE, TELSE, LLAVEIZQ, LLAVEDER;
terminal    String			IGUAL, PUNTOCOMA, COMA, PARENIZQ, PARENDER, CORCHIZQ, CORCHDER;
terminal	String			COMPARADOR, OPLOGICO, VBOOLEANO, OPSUMA, OPPROD;
terminal	String			VSTRING;
terminal	String			VNUMERO;
terminal	String			VID;

non terminal	SimboloBucle		bucle;
non terminal	SimboloCondicional	condicional;
non terminal	SimboloCondElse		condelse;
non terminal	SimboloExpresion	expresion;
non terminal	SimboloPrograma		programa;
non terminal	SimboloClase		clase;
non terminal	SimboloCuerpo		cuerpo;
non terminal	SimboloElemento		elemento;
non terminal	SimboloAsignacion	asignacion;
non terminal  	SimboloFactor		factor;
non terminal	SimboloOperacion	Operacion;
non terminal	SimboloOperacion	Operacion1;
non terminal	SimboloOperacion	Operacion2;
non terminal	SimboloOperacion	Operacion3;
non terminal  	SimboloFuncionInvk	funcionInvk;
non terminal	SimboloFuncionDecl	funcionDecl;
non terminal	SimboloArgs			args;
non terminal	SimboloArgs			nextArg;
non terminal	SimboloContenido	contenido;
non terminal	SimboloParams		params;
non terminal	SimboloParams		nextParam;
non terminal  array;
non terminal  declaracion, inicializacion, rvalue;
non terminal	funcM1, funcM2, funcM3, funcM4, funcM5, funcM6, funcM7;

precedence left OPSUMA, OPPROD;
precedence left OPLOGICO, COMPARADOR;

start with programa;

programa ::=  												{: GlobalVariables.entraBloqueClase(null);
 																GlobalVariables.declaraBuiltInFunctions((EntornoClase)GlobalVariables.entornoActual());
															:}
			clase:c
															{: GlobalVariables.saleBloqueClase();
																// COMPROBAR EXISTENCIA DE VOID MAIN
																RESULT = new SimboloPrograma(c);
															:}
			;
			
clase	::=	TCLASS:t VID:i 									{: try{
																GlobalVariables.asignaClaseID(i);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
															:}
			LLAVEIZQ 										{: GlobalVariables.entraBloqueClase(new Identificador(i, Tipo.Class));
															:}
			cuerpo:c										{: GlobalVariables.saleBloqueClase();
																
															:}
			LLAVEDER										{: RESULT = new SimboloClase(i,c);
															:}
			;
			
cuerpo ::= cuerpo:c elemento:e 								{: RESULT = new SimboloCuerpo(c,e); :}
			|												{: RESULT = null; :}
			;
			
elemento ::= asignacion:a 									{: RESULT = new SimboloElemento(a); :}
			| declaracion	{: /* TODO Falta esta rutina semantica*/ :}
			| funcionDecl:f									{: RESULT = new SimboloElemento(f); :}
			| clase:c										{: RESULT = new SimboloElemento(c); :}
			;
			

declaracion ::= TVAR:t VID:i array:a inicializacion:init PUNTOCOMA
						{:													
							try{
								// TODO Adaptar para aceptar la declaración de arrays
								GlobalVariables.asignaID(i, t);
								TypeCheck.typesMatchAsignacion(i,Tipo.getTipo(t), r.getOperacion().getTipoSubyacente());
							}catch(ErrorSemantico e){
								ErrorHandler.reportaError(e);
							}
							RESULT = new SimboloDeclaracion(t, i, r.getOperacion());
						:}
						| TFINAL TVAR:t VID:i inicializacion:init PUNTOCOMA
						{: 							
							try{
								// TODO De momento no aceptamos declaración de arrays constantes. ¿Queremos hacerlo?
								GlobalVariables.asignaIDConstante(i,t);
								TypeCheck.typesMatchAsignacion(i,Tipo.getTipo(t), r.getOperacion().getTipoSubyacente());
							}catch(ErrorSemantico e){
								ErrorHandler.reportaError(e);
							}
							RESULT = new SimboloAsignacion(t,i,o);
						:};
inicializacion ::= IGUAL Operacion:o | ;

// rvalue deberia ser algo que pueda ser nullable, ya que si no las  declaraciones no pueden ir sin inicializacion
rvalue ::= IGUAL Operacion:o {: :} rvalue | Operacion:o ;

asignacion ::=  VID:i array rvalue:r PUNTOCOMA
					{: 
						try{
							// TODO Adaptar a array. Debera coger la declaracion del tipo del elemento
							GlobalVariables.compruebaID(i);
							GlobalVariables.compruebaAsignacionPermitida(i);
							TypeCheck.typesMatchAsignacion(GlobalVariables.entornoActual().fullGet(i).getId(), GlobalVariables.entornoActual().fullGet(i).getTipo(), o.getTipoSubyacente());
						}catch(ErrorSemantico e){
							ErrorHandler.reportaError(e);
						}
						RESULT = new SimboloAsignacion(i,o);
					:}
					;

funcM1 ::=  {:
				try{
					GlobalVariables.asignaFuncionID(i,t);
				}catch(ErrorSemantico e){
					ErrorHandler.reportaError(e);
				}
			:}
		;
		
funcM2 ::=  {:
				GlobalVariables.entraBloqueFuncion(new Identificador(i, Tipo.getTipo(t)));
				GlobalVariables.asignaEntornoFuncionID(i);
			:}
		;
		
funcM3 ::=  {:
				GlobalVariables.asignaFuncionArgs(i,a);
			:}
		;
		
funcM4 ::= 	{:
				GlobalVariables.saleBloqueFuncion(false);
			:}
		;
		
funcM5 ::=  {:
				try{
					GlobalVariables.asignaFuncionID(i,Tipo.Void);
				}catch(ErrorSemantico e){
					ErrorHandler.reportaError(e);
				}
			:}
		;
			
funcM6 ::=  {:
				GlobalVariables.entraBloqueFuncion(new Identificador(i, Tipo.Void));
				GlobalVariables.asignaEntornoFuncionID(i);
			:}
		;
		
funcM7 ::=  {:
				GlobalVariables.asignaFuncionArgs(i,a);
			:}
		;

funcionDecl ::= TVAR:t VID:i funcM1:M1 PARENIZQ funcM2:M2 args:a funcM3:M3 PARENDER LLAVEIZQ contenido:c funcM4:M4 LLAVEDER 
					{:
						RESULT = new SimboloFuncionDecl(i,Tipo.getTipo(t),a,c);
					:}
					
				|
				TVOID:t VID:i funcM5:M5 PARENIZQ funcM6:M6 args:a funcM7:M7 PARENDER LLAVEIZQ contenido:c funcM4:M4 LLAVEDER
					{:
						RESULT = new SimboloFuncionDecl(i,Tipo.Void,a,c);
					:}
			;
			
funcionInvk ::= VID:i PARENIZQ params:p PARENDER
					{:
					  // En caso de querer admitir sobrecarga de funciones deberiamos 
						// utilizar los parametros para identificar la funcion de forma
						// univoca
						GlobalVariables.compruebaFuncionID(i); 
						TypeCheck.parameterMatch(i, p);
						RESULT = new SimboloFuncionInvk(i,p);
					:}
			;
		
args ::= TVAR:t VID:i array		{: GlobalVariables.asignaID(i,t);
															:}
			nextArg:n										{: RESULT = new SimboloArgs(t,i,n,true);
															:}
		| 													{: RESULT = null;
															:}
		;

nextArg ::= COMA TVAR:t VID:i array	{: GlobalVariables.asignaID(i,t);
															:}
				nextArg:n									{: RESULT = new SimboloArgs(t,i,n,false);
															:}
		|													{: RESULT = null;
															:}
		;
		
contenido ::= contenido:c expresion:e						{: RESULT = new SimboloContenido(c,e); :}
			| contenido:c condicional:d						{: RESULT = new SimboloContenido(c,d); :}
			| contenido:c bucle:b							{: RESULT = new SimboloContenido(c,b); :}
			| contenido:c TRETURN:r Operacion:o PUNTOCOMA	{: try{
																TypeCheck.returnTypeMatch(o);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloContenido(c,r,o); :}
			| 												{: RESULT = null; :}
			;
			
bucle ::= TWHILE PARENIZQ Operacion:o 				{:  try{
															TypeCheck.checkBoolean(o,true);
														}catch(ErrorSemantico e){
															ErrorHandler.reportaError(e);
														}
													:}
				PARENDER LLAVEIZQ 					{: GlobalVariables.entraBloqueWhile(); :}
				contenido:c 						{: GlobalVariables.saleBloqueWhile(); :}
				LLAVEDER							{: RESULT = new SimboloBucle(o,c); :}
				;

condicional ::= TIF PARENIZQ Operacion:o 					{: try{
																TypeCheck.checkBoolean(o,false);
															}catch(ErrorSemantico e){
																ErrorHandler.reportaError(e);
															}
															:}
				PARENDER LLAVEIZQ							{: GlobalVariables.entraBloqueIf(); :}
				contenido:c 								{: GlobalVariables.saleBloqueIf(); :}
				LLAVEDER									{: :}
				condelse:e									{: RESULT = new SimboloCondicional(o,c,e); :}
			;
			
condelse ::= TELSE LLAVEIZQ 								{: GlobalVariables.entraBloqueElse(); :}
				contenido:e 								{: GlobalVariables.saleBloqueElse(); :}
				LLAVEDER									{: RESULT = new SimboloCondElse(e); :}
			|												{: RESULT = null; :}
			;
			
expresion ::= asignacion:a 									{: RESULT = new SimboloExpresion(a); :}
			| funcionInvk:f PUNTOCOMA						{: RESULT = new SimboloExpresion(f); :}
			;
		
Operacion ::= Operacion1:o									{: RESULT = new SimboloOperacion(o); :}
		| Operacion:o OPSUMA:s Operacion:q						{: 
																try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(s));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(s));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,s,q); :}
		;
	
Operacion1 ::= Operacion2:o									{: RESULT = new SimboloOperacion(o); :}
		| Operacion:o OPPROD:p Operacion:q					{: try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(p));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(p));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,p,q); :}
		;
		
Operacion2 ::= Operacion3:o									{: RESULT = new SimboloOperacion(o); :}
		| Operacion:o COMPARADOR:c Operacion:q 				{: try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(c));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(c));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,c,q); :}
		;
		
Operacion3 ::= factor:f 									{: RESULT = new SimboloOperacion(f); :}
		| Operacion:o OPLOGICO:l Operacion:q					{: try{
																	TypeCheck.typesMatch(o.getTipoSubyacente(), TipoOperador.getTipoOperador(l));
																	TypeCheck.typesMatch(q.getTipoSubyacente(), TipoOperador.getTipoOperador(l));
																	TypeCheck.typesMatch(o.getTipoSubyacente(), q.getTipoSubyacente());
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloOperacion(o,l,q); :}
		;
	
//funcionInvk ::= VID:i PARENIZQ params:p PARENDER
factor ::= VID:i array				{: try{
																	GlobalVariables.compruebaID(i);
																}catch(ErrorSemantico e){
																	ErrorHandler.reportaError(e);
																}
																RESULT = new SimboloFactor(i, Tipo.Identificador);
															:}
		| VNUMERO:n 										{: RESULT = new SimboloFactor(n, Tipo.Integer); :}
		| VBOOLEANO:b										{: RESULT = new SimboloFactor(b, Tipo.Boolean); :}
		| VSTRING:s											{: RESULT = new SimboloFactor(s, Tipo.String); :}
		| funcionInvk:f										{: RESULT = new SimboloFactor(f); :}
		;
	
params ::= Operacion:o nextParam:n							{: RESULT = new SimboloParams(o,n,true); :}
		| 													{: RESULT = null; :}
		;

nextParam ::= COMA Operacion:o nextParam:n 					{: RESULT = new SimboloParams(o,n,false); :}
			| 												{: RESULT = null; :}
			;


/*
Las cosas se pueden hacer de diferentes maneras llegados a este punto:
	1. Podemos tener 2 producciones para la declaracion de arrays para 
		 simplificar la gramatica y comprobar en las rutinas semanticas
     que tenemos un rango/indice declarado para todo lo que no sea declaracion
     de parametros

  2. Podemos tener 2 producciones diferentes 1 para la declaracion de variables y 
     su uso en en el codigo de las funciones. Y otra para la declaracion de parametros 
     de funcion

Poll is now on!
*/
array  ::= CORCHIZQ VNUMERO CORCHDER
		 | CORCHIZQ CORCHDER
		 |
		;
